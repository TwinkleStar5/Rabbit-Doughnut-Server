To Begin:

IN SERVER:

1. npm init -y => to install package.json
2. create server.js file => manages the overall server activities
3. create .env file => The .env file holds secret information, like database credentials (passwords) or API keys. It allows the app to use these values without exposing them directly in the code.

4. install 6 PACKAGES into package.json as dependencies =>

   1. express: to connect to the server => Express is a web application framework for Node.js, designed to make it easier to build web applications and APIs. It offers pre-built functions and structures to handle different aspects of web development.
   2. mongoose: to connect to MongoDB which is our database,
   3. jsonwebtoken: to generate a token for users when login
   4. dotenv: to access the env file, => to hide sensitive datas like passwords, API keys from your code. so no one can know even if they enter this code
   5. bcryptjs => to store passwords in database in hashed versions. so no one can know your actual password
   6. cors: to connect to the front end (allow secure sharing of resources between two websites)

5. to make folders in terminal => mkdir folder.name (eg: mkdir models)
   cd means to go inside (cd models)
   cd ../controllers (if you want to go out from a file to another file)

   1. models: Models are like blueprints that defines how the data should look and be stored. If your app is a house, the model is like the architectural plan that defines how rooms, doors, and windows are structured.
   2. controllers: Controllers are traffic managers and bridge between the UI and the database. They decide what to do with incoming requests (CRUD), like fetching or changing data. they will the data which path to go in the database
      List of requests sent from front-end: 1. login/register 2. CREATE: Add items 3. READ: display all items/ display specific item by id 4. UPDATE: edit item 5. DELETE: delete item
   3. middleware: Middleware is like a security guard. It checks who can or cannot enter the app or certain places in the app. like auth, isAdmin

6. to make files inside folders => touch file.name (eg: touch User.js)
7. type in necessary things inside server.js => like show port number in console when nodemon server
8. create connection.js file => to connect to MONGODB database
9. Set up the blueprints needed in User.js

Common import stuffs:

1. require("dotenv").config();
   Imagine you have a box (.env file) where you keep secret notes (configuration settings) for your computer program. These notes could be things like passwords or special codes.

   Now, the dotenv tool is like a helper that opens the box, reads those secret notes, and puts them on a special board (the process.env board). This board is like a shared space where your program can easily see and use those secrets without directly exposing them in the code.

   So, the line require("dotenv").config(); is like saying, "Hey helper (dotenv), go open the box, take out the secret notes, and make them available for the program to use on the shared board (process.env)."

JSON (JavaScript Object Notation)
usage: res.json() => sends a JSON response
eg: {
"name": "John Doe",
"age": 25,
"isStudent": false,
"courses": ["Math", "English", "History"]
}

- JSON is easy for both humans to read and write, and machines to parse and generate. It's a common choice for structuring data exchanged between a client and a server. 
- why we use json format to send response? => to structure data exchange (organizing data in a specific format) that is easy to read by both humans and machines
- JSON response => data sent back from the server in JSON format, often used for API responses or other data exchanges in web development.

res.status(400)

- to set the HTTP status code of the response to 400 (Bad Request). HTTP status codes are part of the HTTP protocol and are used to indicate the success or failure of a request.
- If you don't explicitly set the HTTP status code using res.status(400), Express.js will still send a response to the client, but the status code will default to 200 (OK) if not specified.

400 Bad Request:
Indicates a client-side error due to issues like malformed syntax or invalid parameters.

401 Unauthorized:
Indicates that the client lacks valid authentication credentials for the requested resource.

"configure" => process of setting up or specifying how a certain functionality or component should behave. (specify how something should work)

why use try, catch?

- inside the try, it is to execute the code ... and if it throws an error, the error will be caught by the catch. this is to prevent the whole program from crashing
  try {
    // Code that might throw an exception
  } catch (error) {
    // Code to handle the exception
  }

let's say you have task a,b and c
syncronous operation - you have to wait for each task to finish before moving on to the next task (use when the task can load very quickly)
asynchronous operation - you can process all tasks at the same time (use when the task is is kinda slow to load but is important) (usually paired with await)

res.json(products) vs res.json({products})
    - Assuming products is an array or an object itself => [ /* array elements */ ]
    - Assuming products to be a property within an object => { "products": [ /* array elements */ ] }


why use spread operator? (eg: ...req.body )
- why use spread operator? => If req.body contains multiple fields, using the spread operator allows you to include all existing fields and add or update specific fields without manually listing each one. This is particularly useful when dealing with dynamic data or large objects.

findOne vs findById
- findOne => find the user's specific detail based on the property. 
        eg: User.findOne({ email: "user@example.com" })
- findById => find the user's detail by its unique id. 
        eg: User.findById("someUserId")


why use mongoose?
1. define a schema for your data
2. provides built-in validation for your data based on the defined schema. (eg: type, required, default, min...)
3. Mongoose supports population, allowing you to reference documents in other collections and automatically retrieve the referenced data when querying


HTTP requests
- Hypertext Transfer Protocol
- eg: post, get, put, delete, patch, connect